<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EmojiLocker â€” Encrypted Emoji Messenger</title>
  <meta name="description" content="Zero-backend, client-side AES-GCM emoji messenger." />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 128 128'%3E%3Ctext y='1em' font-size='96'%3E%F0%9F%94%92%3C/text%3E%3C/svg%3E">
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* Style guide variables */
    :root {
      --background: oklch(0.9900 0 0);
      --foreground: oklch(0 0 0);
      --card: oklch(1 0 0);
      --card-foreground: oklch(0 0 0);
      --popover: oklch(0.9900 0 0);
      --popover-foreground: oklch(0 0 0);
      --primary: oklch(0 0 0);
      --primary-foreground: oklch(1 0 0);
      --secondary: oklch(0.9400 0 0);
      --secondary-foreground: oklch(0 0 0);
      --muted: oklch(0.9700 0 0);
      --muted-foreground: oklch(0.4400 0 0);
      --accent: oklch(0.9400 0 0);
      --accent-foreground: oklch(0 0 0);
      --destructive: oklch(0.6300 0.1900 23.0300);
      --destructive-foreground: oklch(1 0 0);
      --border: oklch(0.9200 0 0);
      --input: oklch(0.9400 0 0);
      --ring: oklch(0 0 0);
      --chart-1: oklch(0.8100 0.1700 75.3500);
      --chart-2: oklch(0.5500 0.2200 264.5300);
      --chart-3: oklch(0.7200 0 0);
      --chart-4: oklch(0.9200 0 0);
      --chart-5: oklch(0.5600 0 0);
      --sidebar: oklch(0.9900 0 0);
      --sidebar-foreground: oklch(0 0 0);
      --sidebar-primary: oklch(0 0 0);
      --sidebar-primary-foreground: oklch(1 0 0);
      --sidebar-accent: oklch(0.9400 0 0);
      --sidebar-accent-foreground: oklch(0 0 0);
      --sidebar-border: oklch(0.9400 0 0);
      --sidebar-ring: oklch(0 0 0);
      --font-sans: Geist, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      --font-serif: Georgia, serif;
      --font-mono: Geist Mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius: 0.2rem;
      --shadow-2xs: 0px 1px 4px -1px hsl(0 0% 0% / 0.07);
      --shadow-xs: 0px 1px 4px -1px hsl(0 0% 0% / 0.07);
      --shadow-sm: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 1px 2px -2px hsl(0 0% 0% / 0.13);
      --shadow: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 1px 2px -2px hsl(0 0% 0% / 0.13);
      --shadow-md: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 2px 4px -2px hsl(0 0% 0% / 0.13);
      --shadow-lg: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 4px 6px -2px hsl(0 0% 0% / 0.13);
      --shadow-xl: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 8px 10px -2px hsl(0 0% 0% / 0.13);
      --shadow-2xl: 0px 1px 4px -1px hsl(0 0% 0% / 0.33);
      --tracking-normal: 0em;
      --spacing: 0.25rem;
    }
    .dark {
      --background: oklch(0 0 0);
      --foreground: oklch(1 0 0);
      --card: oklch(0.1400 0 0);
      --card-foreground: oklch(1 0 0);
      --popover: oklch(0.1800 0 0);
      --popover-foreground: oklch(1 0 0);
      --primary: oklch(1 0 0);
      --primary-foreground: oklch(0 0 0);
      --secondary: oklch(0.2500 0 0);
      --secondary-foreground: oklch(1 0 0);
      --muted: oklch(0.2300 0 0);
      --muted-foreground: oklch(0.7200 0 0);
      --accent: oklch(0.3200 0 0);
      --accent-foreground: oklch(1 0 0);
      --destructive: oklch(0.6900 0.2000 23.9100);
      --destructive-foreground: oklch(0 0 0);
      --border: oklch(0.2600 0 0);
      --input: oklch(0.3200 0 0);
      --ring: oklch(0.7200 0 0);
      --chart-1: oklch(0.8100 0.1700 75.3500);
      --chart-2: oklch(0.5800 0.2100 260.8400);
      --chart-3: oklch(0.5600 0 0);
      --chart-4: oklch(0.4400 0 0);
      --chart-5: oklch(0.9200 0 0);
      --sidebar: oklch(0.1800 0 0);
      --sidebar-foreground: oklch(1 0 0);
      --sidebar-primary: oklch(1 0 0);
      --sidebar-primary-foreground: oklch(0 0 0);
      --sidebar-accent: oklch(0.3200 0 0);
      --sidebar-accent-foreground: oklch(1 0 0);
      --sidebar-border: oklch(0.3200 0 0);
      --sidebar-ring: oklch(0.7200 0 0);
      --font-sans: Geist, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      --font-serif: Georgia, serif;
      --font-mono: Geist Mono, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --radius: 0.2rem;
      --shadow-2xs: 0px 1px 4px -1px hsl(0 0% 0% / 0.07);
      --shadow-xs: 0px 1px 4px -1px hsl(0 0% 0% / 0.07);
      --shadow-sm: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 1px 2px -2px hsl(0 0% 0% / 0.13);
      --shadow: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 1px 2px -2px hsl(0 0% 0% / 0.13);
      --shadow-md: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 2px 4px -2px hsl(0 0% 0% / 0.13);
      --shadow-lg: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 4px 6px -2px hsl(0 0% 0% / 0.13);
      --shadow-xl: 0px 1px 4px -1px hsl(0 0% 0% / 0.13), 0px 8px 10px -2px hsl(0 0% 0% / 0.13);
      --shadow-2xl: 0px 1px 4px -1px hsl(0 0% 0% / 0.33);
    }

    /* Base */
    html, body { height: 100%; }
    body {
      background: var(--background);
      color: var(--foreground);
      font-family: var(--font-sans);
    }
    .font-emoji { font-family: system-ui, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, sans-serif; }
    .mono { font-family: var(--font-mono); }

    /* Components */
    .card {
      background: var(--card);
      color: var(--card-foreground);
      border: 1px solid var(--border);
      border-radius: 0.75rem; /* Tailwind's rounded-2xl look */
      box-shadow: none;
      transition: box-shadow .2s ease, transform .1s ease;
    }
    .card:hover { box-shadow: var(--shadow-lg); }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: .5rem;
      padding: .75rem .75rem;
      border-radius: .5rem;
      font-weight: 400;
      line-height: 1;
      border: 1px solid transparent;
      transition: box-shadow .15s ease, transform .05s ease, background-color .15s ease, color .15s ease;
      cursor: pointer;
      user-select: none;
    }
    .btn:active { transform: translateY(1px); }
    .btn-primary {
      background: var(--primary);
      color: var(--primary-foreground);
      box-shadow: none;
    }
    .btn-primary:hover { box-shadow: var(--shadow-sm); }
    .btn-secondary {
      background: var(--secondary);
      color: var(--secondary-foreground);
      border-color: var(--border);
    }
    .btn-quiet {
      background: var(--muted);
      color: var(--foreground);
      border-color: var(--border);
    }

    .field, .select, .textarea {
      width: 100%;
      background: var(--card);
      color: var(--foreground);
      border: 1px solid var(--input);
      border-radius: .5rem;
      padding: .5rem .75rem;
      outline: none;
      transition: box-shadow .15s ease, border-color .15s ease;
    }
    .textarea { min-height: 120px; resize: vertical; }
    .field:focus, .select:focus, .textarea:focus {
      border-color: var(--ring);
      box-shadow: 0 0 0 3px color-mix(in oklab, var(--ring) 12%, transparent);
    }

    .tabs {
      display: inline-flex;
      background: var(--muted);
      padding: .25rem;
      border-radius: .75rem;
      border: 1px solid var(--border);
      width: 100%;
      gap: .25rem;
    }
    .tab {
      flex: 1;
      padding: .375rem .75rem;
      border-radius: .5rem;
      font-size: .875rem;
      border: 1px solid transparent;
      background: transparent;
    }
    .tab.active {
      background: var(--card);
      color: var(--foreground);
      box-shadow: var(--shadow-xs);
      border-color: var(--border);
    }

    .muted { color: var(--muted-foreground); font-size: .8rem; }
    .foot { color: var(--muted-foreground); font-size: .78rem; }

    kbd {
      border: 1px solid var(--border);
      background: var(--muted);
      border-bottom-width: 2px;
      padding: .1rem .35rem;
      border-radius: .375rem;
      font-family: var(--font-mono);
      font-size: .75rem;
    }
  
@media (max-width: 640px) {
  .btn-stack { flex-direction: column; }
  .btn-stack .btn { width: 100%; }
}

</style>
</head>
<body class="min-h-screen antialiased">
  <main class="max-w-3xl mx-auto p-4 md:p-10 space-y-6 md:space-y-8">
    <!-- Header (flat on background) -->
    <header class="pt-2">
      <h1 class="text-2xl md:text-3xl font-semibold">ğŸ” EmojiLocker</h1>
      <p class="mt-2 muted">Client-side AES-GCM encryption. Share only the emoji string. Keys never leave your browser.</p>
    </header>

    <!-- Secret Key (raised card) -->
    <section class="card p-4 md:p-8">
      <div class="space-y-2">
        <label for="key" class="block text-sm font-medium">Secret Key (base64, 256-bit AES)</label>
        <div class="flex flex-col sm:flex-row gap-2 btn-stack">
          <input id="key" class="field mono" placeholder="Paste or generate a keyâ€¦" />
          <div class="flex gap-2 sm:w-auto w-full btn-stack">
            <button id="btn-gen" class="btn btn-primary w-full sm:w-auto">Generate</button>
            <button id="btn-copy-key" class="btn btn-secondary w-full sm:w-auto">Copy</button>
          </div>
        </div>
        <p id="key-hint" class="muted"></p>
        <p class="muted">Tip: share the key out-of-band (never in the same chat as the emojis). Rotate keys regularly.</p>
      </div>
    </section>

    <!-- Emoji style + preview (raised card) -->
    <section class="card p-4 md:p-8">
      <div class="space-y-2">
        <div class="w-full">
          <label for="emoji-style" class="block text-sm font-medium">Emoji Style</label>
          <select id="emoji-style" class="select">
            <option value="default">Default (mixed)</option>
            <option value="happy">Happy ğŸ™‚</option>
            <option value="angry">Angry ğŸ˜ </option>
            <option value="celebration">Celebration ğŸ‰</option>
            <option value="love">Love â¤ï¸</option>
            <option value="nature">Nature ğŸŒ¿</option>
            <option value="food">Food ğŸ•</option>
            <option value="tech">Tech ğŸ¤–</option>
            <option value="animals">Animals ğŸ¾</option>
          </select>
        </div>
        <div class="w-full">
          <label class="block text-sm font-medium">Alphabet Preview</label>
          <div id="alphabet-preview" class="text-2xl font-emoji field overflow-x-auto whitespace-nowrap" title="First 16 symbols of the current alphabet"></div>
        </div>
        <p class="muted">Sender and receiver must pick the <strong>same style</strong> to decode. (We donâ€™t embed the style in the message.)</p>
      </div>
    </section>

    <!-- Encrypt / Decrypt workspace (raised card) -->
    <section class="card p-4 md:p-8">
      <!-- Tabs -->
      <div class="mb-6">
        <div class="tabs">
          <button id="tab-encrypt" class="tab active">Encrypt â†’ Emojis</button>
          <button id="tab-decrypt" class="tab">Decrypt â† Emojis</button>
        </div>
      </div>

      <!-- Encrypt panel -->
      <div id="panel-encrypt" class="space-y-4">
        <div>
          <label for="plain" class="block text-sm font-medium">Your Message</label>
          <textarea id="plain" class="textarea" placeholder="Type something secretâ€¦"></textarea>
        </div>
        <div class="flex gap-2 btn-stack">
          <button id="btn-encrypt" class="btn btn-primary w-full">Encrypt to Emojis</button>
          <button id="btn-clear-encrypt" class="btn btn-quiet w-full">Clear</button>
        </div>
        <div>
          <label class="block text-sm font-medium">Emoji Message (share this)</label>
          <textarea id="emoji-out" readonly class="textarea font-emoji min-h-[140px]"></textarea>
          <div class="flex gap-2 mt-2 btn-stack">
            <button id="btn-copy-emoji" class="btn btn-secondary w-full">Copy Emojis</button>
            <button id="btn-select-emoji" class="btn btn-quiet w-full">Select All</button>
          </div>
        </div>
      </div>

      <!-- Decrypt panel -->
      <div id="panel-decrypt" class="space-y-4 hidden">
        <div>
          <label for="emoji-in" class="block text-sm font-medium">Emoji Message</label>
          <textarea id="emoji-in" class="textarea min-h-[140px]" placeholder="Paste the emoji string hereâ€¦"></textarea>
          <p id="emoji-validate" class="muted mt-1"></p>
        </div>
        <div class="flex gap-2 btn-stack">
          <button id="btn-decrypt" class="btn btn-primary w-full">Decrypt Emojis</button>
          <button id="btn-clear-decrypt" class="btn btn-quiet w-full">Clear</button>
        </div>
        <div>
          <label class="block text-sm font-medium">Decrypted Message</label>
          <textarea id="plain-out" readonly class="textarea"></textarea>
        </div>
      </div>
    </section>

    <!-- Footnotes (flat on background) -->
    <footer class="pt-2 foot space-y-2">
      <p><strong>Security notes:</strong> AES-GCM provides confidentiality and integrity. Keys and encryption run locally in your browser. The emoji transport is just an encoding of the encrypted bytes.</p>
      <p><strong>Compatibility:</strong> Requires a secure context (https or localhost) for Web Crypto. If Clipboard API is blocked by the host pageâ€™s policy, use â€œSelect Allâ€ then <kbd>Ctrl/Cmd+C</kbd>.</p>
    </footer>
  </main>

  <script>
  const stripVS = (s) => (s || "").replace(/\uFE0F/g, "");
  function tokenizeGraphemes(str) {
    if ("Segmenter" in Intl) {
      const seg = new Intl.Segmenter(undefined, { granularity: "grapheme" });
      return Array.from(seg.segment(str), x => stripVS(x.segment));
    }
    return Array.from(stripVS(str));
  }

  const BASE_DEFAULT = [
    "ğŸ˜€","ğŸ˜","ğŸ˜‚","ğŸ˜ƒ","ğŸ˜„","ğŸ˜…","ğŸ˜†","ğŸ˜‰",
    "ğŸ˜Š","ğŸ™‚","ğŸ™ƒ","ğŸ˜‹","ğŸ˜","ğŸ˜","ğŸ˜˜","ğŸ˜—",
    "ğŸ˜™","ğŸ˜š","ğŸ¤—","ğŸ¤©","ğŸ¤”","ğŸ¤¨","ğŸ˜","ğŸ˜‘",
    "ğŸ˜¶","ğŸ™„","ğŸ˜","ğŸ˜£","ğŸ˜¥","ğŸ˜®","ğŸ˜¯","ğŸ˜«",
    "ğŸ˜´","ğŸ¤¤","ğŸ˜ª","ğŸ˜µ","ğŸ¤¯","ğŸ˜±","ğŸ˜³","ğŸ¥³",
    "ğŸ¤ ","ğŸ¤“","ğŸ§","ğŸ‘»","ğŸ’€","ğŸ¤–","ğŸ‘¾","ğŸ‰",
    "âœ¨","ğŸ”¥","ğŸŒŸ","âš¡","ğŸ’«","ğŸŒˆ","ğŸ€","ğŸ‰",
    "ğŸ","ğŸ¥‘","ğŸ£","ğŸ•","ğŸª","ğŸ§","ğŸ§","ğŸ®"
  ].map(stripVS);

  const PAD_EMOJI = stripVS("â—¼");

  const CATEGORY_SEEDS = {
    default: BASE_DEFAULT,
    happy: tokenizeGraphemes("ğŸ˜€ğŸ˜ğŸ˜‚ğŸ¤£ğŸ˜ƒğŸ˜„ğŸ˜…ğŸ˜†ğŸ˜‰ğŸ˜ŠğŸ™‚ğŸ™ƒğŸ˜‹ğŸ˜ğŸ˜ğŸ¥³ğŸ¤©ğŸ¤—ğŸ˜ºğŸ˜¸ğŸ˜¹ğŸ˜»ğŸ˜½ğŸ¥°"),
    angry: tokenizeGraphemes("ğŸ˜ ğŸ˜¡ğŸ¤¬ğŸ˜¤ğŸ˜’ğŸ™„ğŸ˜‘ğŸ˜£ğŸ˜“ğŸ˜«ğŸ˜©ğŸ˜¾ğŸ‘¿ğŸ˜¾"),
    celebration: tokenizeGraphemes("ğŸ‰ğŸŠâœ¨ğŸ‡ğŸ†ğŸ¥³ğŸ†ğŸ–ï¸ğŸ…ğŸˆğŸ‚ğŸ§ğŸ¾ğŸµğŸ¶ğŸŒŸğŸ’«"),
    love: tokenizeGraphemes("â¤ï¸ğŸ©·ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œğŸ¤ğŸ–¤ğŸ¤ğŸ’•ğŸ’ğŸ’˜ğŸ’ğŸ’–ğŸ’—ğŸ˜ğŸ˜˜ğŸ¥°ğŸ˜»ğŸ’ŒğŸ’˜"),
    nature: tokenizeGraphemes("ğŸŒ¿ğŸŒ±ğŸƒğŸŒ²ğŸŒ³ğŸŒ¼ğŸŒ¸ğŸŒºğŸŒ»ğŸŒğŸŒˆğŸŒŠğŸŒğŸ€ğŸğŸ‚ğŸ„ğŸŒ¾â›°ï¸ğŸ”ï¸"),
    food: tokenizeGraphemes("ğŸ•ğŸ”ğŸŸğŸŒ­ğŸ—ğŸ–ğŸ£ğŸ¤ğŸ™ğŸšğŸœğŸğŸ›ğŸ²ğŸ¥—ğŸ¥™ğŸŒ®ğŸŒ¯ğŸ¥ªğŸ°ğŸ«ğŸªğŸ§ğŸ©ğŸ¦ğŸ¨ğŸ§"),
    tech: tokenizeGraphemes("ğŸ¤–ğŸ–¥ï¸ğŸ’»âŒ¨ï¸ğŸ–±ï¸ğŸ“±ğŸ“²ğŸ“¡ğŸ›°ï¸ğŸ’¿ğŸ“€ğŸ§ ğŸ§ªğŸ”¬ğŸ”­âš™ï¸ğŸ”§ğŸ”©ğŸ”ŒğŸ”‹"),
    animals: tokenizeGraphemes("ğŸ¶ğŸ±ğŸ­ğŸ¹ğŸ°ğŸ¦ŠğŸ»ğŸ¼ğŸ¨ğŸ¯ğŸ¦ğŸ®ğŸ·ğŸ¸ğŸµğŸ”ğŸ§ğŸ¦ğŸ¤ğŸ¦†ğŸ¦‰ğŸ´ğŸ¦„ğŸğŸ›ğŸ¦‹ğŸ")
  };

  function unique(arr) {
    const seen = new Set();
    const out = [];
    for (const a of arr) {
      const s = stripVS(a);
      if (!seen.has(s)) { seen.add(s); out.push(s); }
    }
    return out;
  }

  function buildAlphabet(style) {
    const seed = CATEGORY_SEEDS[style] ? CATEGORY_SEEDS[style] : BASE_DEFAULT;
    const uniqSeed = unique(seed);
    const pool = unique([...uniqSeed, ...BASE_DEFAULT]);
    if (pool.length < 64) {
      throw new Error("Alphabet too short after de-duplication.");
    }
    return pool.slice(0, 64);
  }

  let currentStyle = "default";
  let EMOJI_ALPHABET = buildAlphabet(currentStyle);

  function refreshPreview() {
    const prev = document.getElementById("alphabet-preview");
    prev.textContent = EMOJI_ALPHABET.slice(0, 16).join("");
  }

  function bytesToEmoji(bytes) {
    let bitStr = "";
    for (let i = 0; i < bytes.length; i++) {
      bitStr += bytes[i].toString(2).padStart(8, "0");
    }
    const chunks = bitStr.match(/.{1,6}/g) || [];
    if (chunks.length && chunks[chunks.length - 1].length !== 6) {
      chunks[chunks.length - 1] = chunks[chunks.length - 1].padEnd(6, "0");
    }
    let out = chunks.map(c => EMOJI_ALPHABET[parseInt(c, 2)]).join("");
    const mod = out.length % 4;
    if (mod !== 0) out += PAD_EMOJI.repeat(4 - mod);
    return out;
  }

  function emojiToBytes(emojiStr) {
    const clean = (emojiStr || "").replace(/\s+/g, "");
    const noPad = clean.replaceAll(PAD_EMOJI, "");
    const reverse = new Map(EMOJI_ALPHABET.map((e, i) => [e, i]));

    const symbols = tokenizeGraphemes(noPad);
    let invalid = [];
    let bitStr = "";
    for (const symRaw of symbols) {
      const sym = stripVS(symRaw);
      if (!reverse.has(sym)) {
        invalid.push(symRaw);
        continue;
      }
      bitStr += reverse.get(sym).toString(2).padStart(6, "0");
    }
    if (invalid.length > 0) {
      const uniq = [...new Set(invalid)];
      const sample = uniq.slice(0, 10).join(" ");
      const more = uniq.length > 10 ? "â€¦" : "";
      throw new Error("Invalid emoji in message for current style (â€œ" + currentStyle + "â€). Unexpected: " + sample + more);
    }

    const bytes = [];
    for (let i = 0; i + 8 <= bitStr.length; i += 8) {
      bytes.push(parseInt(bitStr.slice(i, i + 8), 2));
    }
    return new Uint8Array(bytes);
  }

  function bufToBase64(buf) {
    const bytes = new Uint8Array(buf);
    let binary = "";
    for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
    return btoa(binary);
  }

  function base64ToBuf(b64) {
    const binary = atob(b64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes.buffer;
  }

  async function generateAesKey() {
    const key = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
    return key;
  }

  async function exportKeyBase64(key) {
    const raw = await crypto.subtle.exportKey("raw", key);
    return btoa(String.fromCharCode(...new Uint8Array(raw)));
  }

  async function importKeyBase64(b64) {
    const binary = atob(b64.trim());
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return crypto.subtle.importKey("raw", bytes.buffer, { name: "AES-GCM" }, false, ["encrypt", "decrypt"]);
  }

  function concatUint8(...parts) {
    const total = parts.reduce((n, p) => n + p.length, 0);
    const out = new Uint8Array(total);
    let off = 0;
    for (const p of parts) { out.set(p, off); off += p.length; }
    return out;
  }

  async function encryptEmojiMessage(plaintext, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder().encode(plaintext);
    const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
    const bundled = concatUint8(iv, new Uint8Array(ct));
    return bytesToEmoji(bundled);
  }

  async function decryptEmojiMessage(emojiStr, key) {
    const bundled = emojiToBytes(emojiStr);
    if (bundled.length < 12) throw new Error("Message too short.");
    const iv = bundled.slice(0, 12);
    const data = bundled.slice(12);
    const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
    return new TextDecoder().decode(pt);
  }

  async function copyText(text) {
    try {
      if (!text) return;
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(text);
        return true;
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "");
      ta.style.position = "fixed";
      ta.style.top = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      const ok = document.execCommand("copy");
      document.body.removeChild(ta);
      return ok;
    } catch (e) {
      return false;
    }
  }

  const els = {
    key: document.getElementById("key"),
    keyHint: document.getElementById("key-hint"),
    btnGen: document.getElementById("btn-gen"),
    btnCopyKey: document.getElementById("btn-copy-key"),
    tabEncrypt: document.getElementById("tab-encrypt"),
    tabDecrypt: document.getElementById("tab-decrypt"),
    panelEncrypt: document.getElementById("panel-encrypt"),
    panelDecrypt: document.getElementById("panel-decrypt"),
    plain: document.getElementById("plain"),
    emojiOut: document.getElementById("emoji-out"),
    btnEncrypt: document.getElementById("btn-encrypt"),
    btnClearEncrypt: document.getElementById("btn-clear-encrypt"),
    btnCopyEmoji: document.getElementById("btn-copy-emoji"),
    btnSelectEmoji: document.getElementById("btn-select-emoji"),
    emojiIn: document.getElementById("emoji-in"),
    emojiValidate: document.getElementById("emoji-validate"),
    btnDecrypt: document.getElementById("btn-decrypt"),
    btnClearDecrypt: document.getElementById("btn-clear-decrypt"),
    plainOut: document.getElementById("plain-out"),
    emojiStyle: document.getElementById("emoji-style"),
    alphabetPreview: document.getElementById("alphabet-preview"),
  };

  let cachedKey = null;

  function hasKey() {
    return (els.key.value || "").trim().length > 0;
  }

  async function getKeyInternal() {
    if (!hasKey()) throw new Error("Provide a key first.");
    try {
      if (!cachedKey || cachedKey.__b64 !== els.key.value.trim()) {
        cachedKey = await importKeyBase64(els.key.value);
        cachedKey.__b64 = els.key.value.trim();
      }
      return cachedKey;
    } catch (e) {
      throw new Error("Invalid key format. Paste the base64 key generated here.");
    }
  }

  function showEncrypt() {
    els.panelEncrypt.classList.remove("hidden");
    els.panelDecrypt.classList.add("hidden");
    els.tabEncrypt.classList.add("active");
    els.tabDecrypt.classList.remove("active");
  }
  function showDecrypt() {
    els.panelEncrypt.classList.add("hidden");
    els.panelDecrypt.classList.remove("hidden");
    els.tabDecrypt.classList.add("active");
    els.tabEncrypt.classList.remove("active");
  }

  els.tabEncrypt.addEventListener("click", showEncrypt);
  els.tabDecrypt.addEventListener("click", showDecrypt);

  function setStyle(style) {
    currentStyle = style;
    EMOJI_ALPHABET = buildAlphabet(style);
    refreshPreview();
    els.emojiIn.dispatchEvent(new Event("input"));
  }
  els.emojiStyle.addEventListener("change", (e) => setStyle(e.target.value));

  els.btnGen.addEventListener("click", async () => {
    els.keyHint.textContent = "Generatingâ€¦";
    try {
      const key = await crypto.subtle.generateKey({ name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]);
      const raw = await crypto.subtle.exportKey("raw", key);
      const b64 = btoa(String.fromCharCode(...new Uint8Array(raw)));
      els.key.value = b64;
      cachedKey = key;
      cachedKey.__b64 = b64;
      els.keyHint.textContent = "New 256-bit key generated. Keep it secret.";
    } catch (e) {
      els.keyHint.textContent = "Failed to generate key: " + (e && e.message ? e.message : e);
    }
  });

  els.btnCopyKey.addEventListener("click", async () => {
    const ok = await copyText(els.key.value);
    els.keyHint.textContent = ok ? "Key copied." : "Copy blocked. Use Select All + Ctrl/Cmd+C.";
  });

  els.btnEncrypt.addEventListener("click", async () => {
    els.emojiOut.value = "";
    if (els.plainOut) els.plainOut.value = "";
    try {
      const key = await getKeyInternal();
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const enc = new TextEncoder().encode(els.plain.value);
      const ct = await crypto.subtle.encrypt({ name: "AES-GCM", iv }, key, enc);
      const bundled = (function concatUint8(){const parts=[iv,new Uint8Array(ct)];const total=parts.reduce((n,p)=>n+p.length,0);const out=new Uint8Array(total);let off=0;for(const p of parts){out.set(p,off);off+=p.length}return out;})();
      els.emojiOut.value = (function bytesToEmoji(bytes){let bitStr="";for(let i=0;i<bytes.length;i++){bitStr+=bytes[i].toString(2).padStart(8,"0")}const chunks=bitStr.match(/.{1,6}/g)||[];if(chunks.length&&chunks[chunks.length-1].length!==6){chunks[chunks.length-1]=chunks[chunks.length-1].padEnd(6,"0")}let out=chunks.map(c=>EMOJI_ALPHABET[parseInt(c,2)]).join("");const mod=out.length%4;if(mod!==0) out+=PAD_EMOJI.repeat(4-mod);return out;})(bundled);
    } catch (e) {
      els.emojiOut.value = "ERROR: " + (e && e.message ? e.message : e);
    }
  });

  els.btnClearEncrypt.addEventListener("click", () => {
    els.plain.value = "";
    els.emojiOut.value = "";
  });

  els.btnCopyEmoji.addEventListener("click", async () => {
    const ok = await copyText(els.emojiOut.value);
    els.keyHint.textContent = ok ? "Emoji message copied." : "Copy blocked. Use Select All + Ctrl/Cmd+C.";
  });

  els.btnSelectEmoji.addEventListener("click", () => {
    els.emojiOut.focus();
    els.emojiOut.select();
  });

  els.emojiIn.addEventListener("input", () => {
    const clean = (els.emojiIn.value || "").replace(/\s+/g, "").replaceAll(PAD_EMOJI, "");
    const symbols = tokenizeGraphemes(clean);
    const reverse = new Map(EMOJI_ALPHABET.map((e, i) => [e, i]));
    let invalid = 0;
    for (const s of symbols) if (!reverse.has(stripVS(s))) invalid++;
    if (invalid === 0 || symbols.length === 0) {
      els.emojiValidate.textContent = "";
      els.emojiValidate.className = "muted mt-1";
    } else {
      els.emojiValidate.textContent = invalid + " invalid symbol" + (invalid > 1 ? "s" : "") + " for style â€œ" + currentStyle + "â€ will be rejected.";
      els.emojiValidate.className = "muted mt-1";
    }
  });

  els.btnDecrypt.addEventListener("click", async () => {
    els.emojiOut.value = "";
    els.plainOut.value = "";
    try {
      const key = await getKeyInternal();
      // decode
      const clean = (els.emojiIn.value || "").replace(/\s+/g, "").replaceAll(PAD_EMOJI, "");
      const reverse = new Map(EMOJI_ALPHABET.map((e, i) => [e, i]));
      const symbols = tokenizeGraphemes(clean);
      let bitStr = "";
      for (const symRaw of symbols) {
        const sym = stripVS(symRaw);
        if (!reverse.has(sym)) throw new Error("Invalid emoji in message for current style.");
        bitStr += reverse.get(sym).toString(2).padStart(6, "0");
      }
      const bytes = [];
      for (let i = 0; i + 8 <= bitStr.length; i += 8) {
        bytes.push(parseInt(bitStr.slice(i, i + 8), 2));
      }
      const bundled = new Uint8Array(bytes);
      if (bundled.length < 12) throw new Error("Message too short.");
      const iv = bundled.slice(0, 12);
      const data = bundled.slice(12);
      const pt = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
      els.plainOut.value = new TextDecoder().decode(pt);
    } catch (e) {
      els.plainOut.value = "ERROR: " + (e && e.message ? e.message : e);
    }
  });

  // Init
  setStyle("default");
  showEncrypt();
  refreshPreview();
  </script>
</body>
</html>

